<!-- public/dashboard.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>실시간 거래 대시보드</title>
  <!-- Bootstrap CSS 로드 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
        integrity="sha384-ENjdO4Dr2bkBIFxQpeoAAtc+LyA+6PaSHH3bzqlD2taSXZ8o3bmFf8n5XhIlyQ8w" crossorigin="anonymous">
  <!-- Socket.IO 클라이언트 스크립트 로드 -->
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js" crossorigin="anonymous"></script>
  <style>
    body { margin: 20px; background-color: #f8f9fa; }
    h1 { margin-bottom: 30px; }
    .table { border-collapse: separate; border-spacing: 0; }
    .table th, .table td { border: 1px solid #dee2e6; text-align: center; vertical-align: middle; }
    .table thead th { background-color: #343a40; color: #fff; }
    .status-connected { color: green; font-weight: bold; }
    .status-disconnected { color: red; font-weight: bold; }
    .row-connected { background-color: #e9f7ef; }
    .row-disconnected { background-color: #fbeeee; }
    .goal-message { position: fixed; top: 20px; right: 20px; z-index: 1000; }
  </style>
</head>
<body>
<div class="container">
  <a href="/logout" class="btn btn-danger mb-3">로그아웃</a>
  <h1 class="text-center">실시간 거래 대시보드</h1>
  <!-- 거래 정보 테이블 -->
  <table id="data-table" class="table table-striped table-hover">
    <thead>
    <tr>
      <th>이름</th>
      <th>사용자 IP 주소</th>
      <th>총 자산 (USDT)</th>
      <th>현재 수익율 (%)</th>
      <th>미실현 손익 (USDT)</th>
      <th>총 자산 (미실현 손익 포함) (USDT)</th>
      <th>누적 수익금 (USDT)</th>
      <th>목표 수익금 (USDT)</th>
      <th>서버 통신 상태</th>
      <th>타임스탬프</th>
      <th>승인</th>
      <th>승인취소</th>
      <th>목표 달성</th>
    </tr>
    </thead>
    <tbody id="data-body">
      <!-- 실시간 거래 정보가 여기에 업데이트됩니다 -->
    </tbody>
  </table>
</div>

<div id="goal-message-container" class="goal-message"></div>

<!-- Bootstrap JS 로드 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ROAPyY4h6a9kAqV6iEOJq9k6lZPqqvIy3s6eGZKlj/DuCkC8rjCGY3bEhVB0jRiS" crossorigin="anonymous"></script>

<script>
  const socket = io();
  const clientData = {};
  const clientTimeouts = {};
  const DATA_TIMEOUT = 15000;       // update_data 이벤트 타임아웃 (15초)
  const TERMINATION_TIMEOUT = 30000; // update_data 미수신 시(프로그램 종료 등)로 간주하는 타임아웃 (30초)

  // 소켓 연결 시 초기 데이터 요청
  socket.on('connect', () => {
    console.log('서버에 연결되었습니다.');
    socket.emit('request_initial_data');
  });

  socket.on('initial_data', (allUserData) => {
    console.log('초기 데이터 수신:', allUserData);
    allUserData.forEach(data => {
      clientData[data.name] = data;
    });
    updateTable();
  });

  socket.on('update_user_info', (data) => {
    console.log('사용자 정보 업데이트:', data);
    clientData[data.name] = { ...clientData[data.name], ...data };
    updateTable();
  });

  socket.on('update_target_profit', (data) => {
    const { name, targetProfit } = data;
    if (clientData[name]) {
      clientData[name].target_profit = targetProfit;
      console.log(`목표 수익금 업데이트: ${name} - ${targetProfit} USDT`);
      updateTable();
    }
  });

  // update_data 이벤트: update_data가 오면 해당 클라이언트의 데이터와 타임스탬프를 업데이트하고,
  // 기존 타이머를 초기화한 후 30초 후 타이머 콜백을 등록하여, update_data가 없으면 상태를 변경합니다.
  socket.on('update_data', (data) => {
    console.log('데이터 업데이트 수신:', data);
    // 만약 data에 timestamp가 없으면 현재 시간을 넣습니다.
    if (!data.timestamp) {
      data.timestamp = new Date().toISOString();
    }
    clientData[data.name] = { ...clientData[data.name], ...data };

    // 타이머 초기화 및 재설정
    if (clientTimeouts[data.name]) {
      clearTimeout(clientTimeouts[data.name]);
    }
    clientTimeouts[data.name] = setTimeout(() => {
      // 30초 동안 update_data 이벤트가 없으면 해당 클라이언트의 상태를 "Disconnected"로 변경
      clientData[data.name].server_status = 'Disconnected';
      clientData[data.name].total_balance = 0;
      clientData[data.name].current_profit_rate = 0;
      clientData[data.name].unrealized_pnl = 0;
      clientData[data.name].current_total_asset = 0;
      // 승인 상태 리셋 (승인 버튼 활성화)
      clientData[data.name].isApproved = false;
      updateTable();
    }, TERMINATION_TIMEOUT);

    updateTable();
  });

  // 서버와의 연결이 끊어졌을 때: 모든 클라이언트의 숫자 데이터와 상태를 초기화하지만,
  // 승인 상태는 그대로 유지합니다.
  socket.on('disconnect', () => {
    console.log('서버와의 연결이 끊어졌습니다.');
    Object.keys(clientData).forEach(name => {
      clientData[name].server_status = 'Disconnected';
      clientData[name].total_balance = 0;
      clientData[name].current_profit_rate = 0;
      clientData[name].unrealized_pnl = 0;
      clientData[name].current_total_asset = 0;
      // 승인 상태는 유지 (disconnect 이벤트 시 변경하지 않음)
    });
    updateTable();
  });

  socket.on('update_approval_status', (data) => {
    console.log('승인 상태 업데이트:', data);
    if (clientData[data.name]) {
      clientData[data.name].isApproved = data.isApproved;
      updateTable();
    }
  });

  socket.on('goal_achieved', (data) => {
    const { name } = data;
    console.log(`목표 달성 이벤트: ${name}`);
    // 목표 달성 시 자동으로 승인취소 명령 전송
    sendCommand('cancel_approve', name);
    showGoalAchievedMessage(name);
  });

  // Socket.IO 에러 이벤트 처리 (에러 메시지 표시)
  socket.on('error', (error) => {
    console.error('Socket error:', error);
    showTemporaryMessage(error.message || '알 수 없는 오류 발생');
  });

  // 주기적인 검사: 각 클라이언트의 timestamp를 확인하여, update_data 미수신 상태(30초 이상 경과)인 경우 처리
  setInterval(() => {
    const now = Date.now();
    Object.keys(clientData).forEach(name => {
      const client = clientData[name];
      if (client.timestamp) {
        const clientTime = new Date(client.timestamp).getTime();
        if (now - clientTime > TERMINATION_TIMEOUT) {
          client.server_status = 'Disconnected';
          client.total_balance = 0;
          client.current_profit_rate = 0;
          client.unrealized_pnl = 0;
          client.current_total_asset = 0;
          client.isApproved = false;
        }
      }
    });
    updateTable();
  }, 5000);

  // 테이블 업데이트 함수: clientData 객체의 최신 데이터를 테이블에 반영
  function updateTable() {
    const tbody = document.getElementById('data-body');
    tbody.innerHTML = '';
    Object.values(clientData).forEach(data => {
      const row = document.createElement('tr');
      if (data.server_status === 'Connected') {
        row.classList.add('row-connected');
      } else {
        row.classList.add('row-disconnected');
      }
      // 이름
      const nameCell = document.createElement('td');
      nameCell.textContent = data.name || '';
      row.appendChild(nameCell);
      // 사용자 IP 주소
      const ipCell = document.createElement('td');
      ipCell.textContent = data.user_ip || '';
      row.appendChild(ipCell);
      // 총 자산 (USDT)
      const totalBalanceCell = document.createElement('td');
      totalBalanceCell.textContent = data.total_balance != null ? parseFloat(data.total_balance).toLocaleString() : '';
      row.appendChild(totalBalanceCell);
      // 현재 수익율 (%)
      const profitRateCell = document.createElement('td');
      profitRateCell.textContent = data.current_profit_rate != null ? parseFloat(data.current_profit_rate).toFixed(2) + '%' : '';
      row.appendChild(profitRateCell);
      // 미실현 손익 (USDT)
      const unrealizedPnlCell = document.createElement('td');
      unrealizedPnlCell.textContent = data.unrealized_pnl != null ? parseFloat(data.unrealized_pnl).toLocaleString() : '';
      row.appendChild(unrealizedPnlCell);
      // 총 자산 (미실현 손익 포함) (USDT)
      const totalWithPnlCell = document.createElement('td');
      totalWithPnlCell.textContent = data.current_total_asset != null ? parseFloat(data.current_total_asset).toLocaleString() : '';
      row.appendChild(totalWithPnlCell);
      // 누적 수익금 (USDT)
      const profitCell = document.createElement('td');
      profitCell.textContent = data.display_profit != null ? parseFloat(data.display_profit).toLocaleString() : '';
      row.appendChild(profitCell);
      // 목표 수익금 (USDT) - 인풋과 설정 버튼 포함
      const targetProfitCell = document.createElement('td');
      const targetProfitInput = document.createElement('input');
      targetProfitInput.type = 'number';
      targetProfitInput.min = '0';
      targetProfitInput.step = '0.01';
      targetProfitInput.value = data.target_profit != null ? parseFloat(data.target_profit).toFixed(2) : '500';
      targetProfitInput.classList.add('form-control', 'form-control-sm');
      targetProfitInput.style.width = '100px';
      targetProfitInput.id = `target-profit-${data.name}`;
      targetProfitCell.appendChild(targetProfitInput);
      const setButton = document.createElement('button');
      setButton.textContent = 'Set';
      setButton.classList.add('btn', 'btn-primary', 'btn-sm', 'mt-1');
      setButton.onclick = () => setTargetProfit(data.name);
      targetProfitCell.appendChild(setButton);
      row.appendChild(targetProfitCell);
      // 서버 통신 상태
      const serverStatusCell = document.createElement('td');
      serverStatusCell.textContent = data.server_status || '';
      if (data.server_status === 'Connected') {
        serverStatusCell.classList.add('status-connected');
      } else {
        serverStatusCell.classList.add('status-disconnected');
      }
      row.appendChild(serverStatusCell);
      // 타임스탬프
      const timestampCell = document.createElement('td');
      timestampCell.textContent = data.timestamp || '';
      row.appendChild(timestampCell);
      // 승인 버튼
      const approveCell = document.createElement('td');
      const approveButton = document.createElement('button');
      approveButton.textContent = '승인';
      approveButton.classList.add('btn', 'btn-success', 'btn-sm');
      approveButton.onclick = () => sendCommand('approve', data.name);
      approveButton.disabled = data.isApproved;
      approveCell.appendChild(approveButton);
      row.appendChild(approveCell);
      // 승인취소 버튼
      const cancelApproveCell = document.createElement('td');
      const cancelApproveButton = document.createElement('button');
      cancelApproveButton.textContent = '승인취소';
      cancelApproveButton.classList.add('btn', 'btn-warning', 'btn-sm');
      cancelApproveButton.onclick = () => sendCommand('cancel_approve', data.name);
      cancelApproveButton.disabled = !data.isApproved;
      cancelApproveButton.id = `cancel-approve-${data.name}`;
      cancelApproveCell.appendChild(cancelApproveButton);
      row.appendChild(cancelApproveCell);
      // 목표 달성 여부
      const goalAchievedCell = document.createElement('td');
      if (data.display_profit >= data.target_profit) {
        goalAchievedCell.textContent = '목표를 달성했습니다';
        goalAchievedCell.classList.add('text-success', 'fw-bold');
      } else {
        goalAchievedCell.textContent = '';
      }
      row.appendChild(goalAchievedCell);
      tbody.appendChild(row);
      // 목표 달성 시 자동 승인취소 트리거 (원한다면 유지)
      if (data.display_profit >= data.target_profit && data.isApproved) {
        const cancelButton = document.getElementById(`cancel-approve-${data.name}`);
        if (cancelButton && !cancelButton.disabled) {
          cancelButton.click();
          console.log(`자동으로 승인취소 버튼이 클릭되었습니다: ${data.name}`);
        }
      }
    });
  }

  function sendCommand(command, clientName) {
    socket.emit('send_command', { command: command, name: clientName });
    console.log(`명령 전송: ${command} - ${clientName}`);
  }

  function setTargetProfit(clientName) {
    const input = document.getElementById(`target-profit-${clientName}`);
    const targetProfit = parseFloat(input.value);
    if (isNaN(targetProfit) || targetProfit <= 0) {
      alert('유효한 목표 수익금을 입력하세요.');
      return;
    }
    socket.emit('set_target_profit', { name: clientName, targetProfit: targetProfit });
    console.log(`목표 수익금 설정: ${clientName} - ${targetProfit} USDT`);
    showTemporaryMessage(`${clientName}의 목표 수익금이 ${targetProfit.toLocaleString()} USDT로 설정되었습니다.`);
  }

  function showTemporaryMessage(message) {
    const container = document.getElementById('goal-message-container');
    const alertDiv = document.createElement('div');
    alertDiv.classList.add('alert', 'alert-info', 'alert-dismissible', 'fade', 'show');
    alertDiv.role = 'alert';
    alertDiv.innerHTML = `
      <strong>알림:</strong> ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    `;
    container.appendChild(alertDiv);
    setTimeout(() => {
      const alert = bootstrap.Alert.getOrCreateInstance(alertDiv);
      alert.close();
    }, 5000);
  }

  function showGoalAchievedMessage(name, message = '목표를 달성했습니다.') {
    const container = document.getElementById('goal-message-container');
    const alertDiv = document.createElement('div');
    alertDiv.classList.add('alert', 'alert-success', 'alert-dismissible', 'fade', 'show');
    alertDiv.role = 'alert';
    alertDiv.innerHTML = `
      <strong>${name}:</strong> ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    `;
    container.appendChild(alertDiv);
    setTimeout(() => {
      const alert = bootstrap.Alert.getOrCreateInstance(alertDiv);
      alert.close();
    }, 5000);
  }
</script>
</body>
</html>
